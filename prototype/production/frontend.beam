import "../project.beam" as project
import "../vpc.beam" as vpc
import "../gateway.beam" as gateway

ENVIRONMENT = "production"

AWS::SecurityGroup elb {
    vpcId: @(AWS::Vpc vpc.vpc.vpcId)
        
    ingress {
        fromPort: 80
        toPort: 80
        protocol: "tcp"
        cidrBlock: "0.0.0.0/0"
    }

    ingress {
        fromPort: 443
        toPort: 443
        protocol: "tcp"
        cidrBlock: "0.0.0.0/0"
    }
}

AWS::ElasticLoadBalancer web {
    name: "${project.NAME}-web-${project.SERIAL}" 

    listener {
        loadBalancerPort: 80
        instanceProtocol: "http"
        instancePort: 80
    }

    listener {
        loadBalancerPort: 443
        instanceProtocol: "https"
        instancePort: 80
    }

    healthCheck {
        protocol: "http"
        port: 80
        path: "/_ping"
        timeout: 5
        interval: 6
        unhealthyThreshold: 2
        healthyThreshold: 2
    }

    subnets: #(AWS::Subnet vpc.public)
    securityGroups: [@(AWS::SecurityGroup elb)]
}

AWS::HostedZoneRecord prod.${project.SUBDOMAIN} {
    zoneId: @(AWS::HostedZone route53.public.zoneId)
    name: "prod.${project.SUBDOMAIN}"
    type: "CNAME"
    ttl: 300
    records: [@(AWS::ElasticLoadBalancer web.canonicalHostedZoneName)]
}

AWS::SecurityGroup frontend {
    vpcId: @(AWS::Vpc vpc.vpc.vpcId)

    ingress {
        fromPort: 80
        toPort: 80
        protocol: "tcp"
        securityGroups: [@(AWS::SecurityGroup elb)]
    }

    ingress {
        fromPort: 22
        toPort: 22
        protocol: "tcp"
        securityGroups: [@(AWS::SecurityGroup elb)]
    }

    ingress {
        fromPort: 80
        toPort: 80
        protocol: "tcp"
        securityGroups: [@(AWS::SecurityGroup elb)]
    }

    ingress {
        fromPort: 8080
        toPort: 8080
        protocol: "tcp"
        securityGroups: [@(AWS::SecurityGroup elb)]
    }
}

AWS::LaunchConfiguration frontend {
    name: "${project.NAME} frontend ${ENVIRONMENT} v${project.SERIAL}"

    image: "ami-0ddcc69ab30ed9c03"
    instanceType: "t2.medium"
    keyPair: @(AWS::KeyPair project.key-pair)

    securityGroups: [@(AWS::SecurityGroup frontend)]
}

AWS::AutoscalingGroup frontend {
    autoscaleGroupName: @(AWS::LaunchConfiguration frontend.name)
    launchConfigurationName: @(AWS::LaunchConfiguration frontend.name)
    loadBalancerNames: [@{AWS::ElasticLoadBalancer web.name)]
    vpcZoneIdentitiers: #(AWS::Subnet vpc.private)
    defaultCoolDown: 300
    healthCheckType: "ec2"
    
    minSize: 4
    maxSize: 8

    tags: ${project.defaultTags}
}

AWS::AutoscalingPolicy high-cpu-scale-up {
    name: "high-cpu-scale-up"
    autoscaleGroupName: @(AWS::AutoscalingGroup frontend.autoscaleGroupName)
    adjustmentType: "ChangeInCapacity"
    scalingAdjustment: 4
    coolDown: 120
}

AWS::CloudwatchMetricAlarm frontend-autoscaling-cpu-high {
    name: @(AWS::AutoscalingPolicy high-cpu-scale-up.name)
    metricName: "CPUUtilization"
    namespace: "AWS/EC2"
    evaluationPeriods: 1
    period: 60
    threshold: 60
    statistic: "Average"
    comparisonOperator: "GreaterThanThreshold"

    dimensions: {
        AutoScalingGroupName: @(AWS::AutoscalingGroup frontend.autoscaleGroupName)
    }

    alarmActions: [@(AWS::AutoscalingPolicy high-cpu-scale-up.arn)]
}

AWS::AutoscalingPolicy high-cpu-scale-down {
    name: "high-cpu-scale-down"
    autoscaleGroupName: @(AWS::AutoscalingGroup frontend.autoscaleGroupName)
    adjustmentType: "ChangeInCapacity"
    scalingAdjustment: -4
    coolDown: 300
}

AWS::CloudwatchMetricAlarm frontend-autoscaling-cpu-low {
    name: @(AWS::AutoscalingPolicy high-cpu-scale-down.name)
    metricName: "CPUUtilization"
    namespace: "AWS/EC2"
    evaluationPeriods: 1
    period: 300
    threshold: 20
    statistic: "Average"
    comparisonOperator: "LessThanThreshold"

    dimensions: {
        AutoScalingGroupName: @(AWS::AutoscalingGroup frontend.autoscaleGroupName)
    }

    alarmActions: [@(AWS::AutoscalingPolicy high-cpu-scale-down.arn)]
}